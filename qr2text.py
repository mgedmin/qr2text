#!/usr/bin/env python3
"""
Convert SVG images containing QR codes generated by PyQRCode to ASCII art,
for displaying in a terminal.
"""

import argparse
import re
import sys
import xml.etree

__version__ = '0.1'


class Error(Exception):
    pass


SVG_NS = 'http://www.w3.org/2000/svg'


TRANSFORM_SCALE_RX = re.compile(r'^scale[(](\d+)[)]$')


class PathParser:

    # https://svgwg.org/svg2-draft/paths.html#PathDataBNF

    TOKEN_RX = re.compile(
        '|'.join([
            r'(?P<wsp>\s+)',
            r'(?P<comma>,)',
            r'(?P<number>[-+]?(?:\d*\.\d+|\d+)(?:[eE][-+]?\d+)?)',
            r'(?P<command>[MmZzLlHhVvCcSsQqTtAa])',
            r'(?P<error>.)',  # must be last
        ])
    )

    @classmethod
    def tokenize(cls, path):
        for m in cls.TOKEN_RX.finditer(path):
            kind = m.lastgroup
            value = m.group()
            if kind == 'wsp':
                continue
            if kind == 'error':
                pos = m.start()
                raise Error(f'Bad SVG path at position {pos}: {value}')
            yield (kind, value)

    @classmethod
    def parse(cls, path):
        command = []
        for kind, value in cls.tokenize(path):
            if kind == 'command':
                if command:
                    yield tuple(command)
                command = [value]
            elif kind == 'number':
                command.append(float(value))
            elif kind == 'comma':
                # let's just skip these
                continue
            else:
                assert False, f'did not expect {kind}'
        if command:
            yield tuple(command)


class Canvas:

    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.pixels = [[0] * width for _ in range(height)]

    def horizontal_line(self, x, y, width):
        assert width > 0
        # PyQRCode draws 1-pixel thick horizontal lines, which means the
        # x coordinates are whole numbers, and the y coordinate is shifted by
        # 0.5 to point to the middle of the pixel
        y = int(y - 0.5)
        if 0 <= y < self.height:
            for x in range(int(x), int(x + width)):
                if 0 <= x < self.width:
                    self.pixels[y][x] = 1

    def to_ascii_art(self, chars):
        return '\n'.join(
            ''.join(chars[px] for px in row) for row in self.pixels)

    def __str__(self):
        return self.to_ascii_art('.X')


class Path:

    def __init__(self, canvas):
        # Technically the very first path drawing command must be an absolute
        # move_to, so the initial coordinates are undefined.
        self.x = 0
        self.y = 0
        self.canvas = canvas

    def move_to(self, x, y):
        self.x = x
        self.y = y

    def move_by(self, dx, dy):
        self.x += dx
        self.y += dy

    def horizontal_line_rel(self, dx):
        if dx > 0:
            self.canvas.horizontal_line(self.x, self.y, dx)
        elif dx < 0:
            self.canvas.horizontal_line(self.x + dx, self.y, -dx)
        self.x += dx

    def draw(self, commands):
        for cmd in commands:
            if cmd[0] == 'M' and len(cmd) == 3:
                self.move_to(cmd[1], cmd[2])
            elif cmd[0] == 'm' and len(cmd) == 3:
                self.move_by(cmd[1], cmd[2])
            elif cmd[0] == 'h' and len(cmd) == 2:
                self.horizontal_line_rel(cmd[1])
            else:
                raise Error(f'Did not expect drawing command {cmd[0]}'
                            f' with {len(cmd)-2} parameters')


class QR:

    def __init__(self, size):
        self.size = size
        self.canvas = Canvas(size, size)

    def to_ascii_art(self):
        return self.canvas.to_ascii_art(u' \u2588')

    @classmethod
    def from_svg(cls, fileobj):
        tree = xml.etree.ElementTree.parse(fileobj)
        root = tree.getroot()
        if root.tag != f"{SVG_NS}svg":
            raise Error("This is not an SVG image")
        width = int(root.get('width'))
        height = int(root.get('height'))
        if width != height:
            raise Error(f"The image is not square ({width}x{height})")
        if root.get('class') != 'pyqrcode':
            raise Error("The image was not generated by PyQRCode")
        path = root.find('path')
        if path.get('class') != 'pyqrline':
            raise Error("Did not find the QR code in the image")
        # path.get('transform') should be something like "scale(8)"
        # path.get('stroke') should be '#000'
        # path.get('d') is the QR code itself, encoded as drawing commands
        transform = path.get('transform')
        m = TRANSFORM_SCALE_RX.match(transform)
        scale = int(m.group(1))
        size = width // scale
        qr = cls(size)
        d = path.get('d')
        Path(qr.canvas).draw(PathParser.parse(d))
        return qr


def main():
    parser = argparse.ArgumentParser(
        description="Convert PyQRCode SVG images to ASCII art")
    parser.add_argument("--version", action="version",
                        version="%(prog)s version " + __version__)
    parser.add_argument("filename", type=argparse.FileType)
    args = parser.parse_args()

    with args.filename as fp:
        qr = QR.from_svg(fp)
    print(qr.to_ascii_art())


if __name__ == "__main__":
    try:
        main()
    except (Error, KeyboardInterrupt) as e:
        sys.exit(e)
